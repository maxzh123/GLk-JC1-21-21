package Sample;
  /** Задание:
1. запустить убедится, что работает.
2. разобраться как работает.
3. Челенж. Переделываем, так что количество вычислений остатка от деления было как можно меньше. Посмотрим у кого что получится.
* */

public class Sample6 {

    private static int count = 0;

      public static void main(String[] arg) { //Сообщаем компилятору что класс имеет публичный метод, не возвращающий рельтатов, но принимающий в качестве аргументов масив строк.
        for (int i = 1; i <= 1000; i++) {//для целочисленного i установить значение 0;выполнять блок пока i меньше 100; после каждого исполнения увеличить i на 1
            if (isPrime(i)) {// Вызываем функцию которая проверит является ли число простым если да - выводим его
                System.out.println(i);//Достаем системный поток out и вызываем его метод println (напечатать и перевести строку). В качестве аргумента передаем то, что хотим напечатать.
            }//блока иначе нет. эта ситуация будет проигнорирована. никаких действий не выполнится.
        }
        System.out.println("Произвели сравнений остатка от деления:" + count);//Достаем системный поток out и вызываем его метод println (напечатать и перевести строку). В качестве аргумента передаем то, что хотим напечатать.
    }

    private static boolean isPrime(int number) {
        if (number == 0 || number == 1 || number == 2) { //Если число которое нам передали одно из 0 1 2
            return true;//возвращаем да
        } else {//иначе
            for (int i = 2
                 ; i <= Math.sqrt(number); i++) { //изначально 78189 операций сравнения
                count++;                                   // согласно теореме можно сравнивать до корня из числа, операций - 5288
                if (number % i == 0) {                     // тк все простые числа нечетные, кроме 2, можно изменить шаг цикла for, операций будет 4740
                    return false;
                }
            }
        }
        return true;
    }


}

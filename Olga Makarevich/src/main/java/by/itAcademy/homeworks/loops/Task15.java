package by.itAcademy.homeworks.loops;

// Найти среди чисел от 50 до 70 второе простое число (число называют простым, если оно делится без остатка
// только на 1 и себя) и завершить цикл с использованием break.

public class Task15 {
    public static void main(String[] args) {
        System.out.println(foundSecondNaturalNumber(50,70,2));

    }

    public static int foundSecondNaturalNumber (int a, int b, int c) {
        int count = 0;
        for (int i = a; i <= b; i++){
            if (isPrime(i)) {
                count++;
                if (c ==count) {
                    return i;
                }
            }
        }
        return 0;
    }

    public static boolean isPrime(int number){
        for (int i = 2; i < Math.sqrt(number); i++){
            if (number % i == 0) {
                return false;
            }
        }
        return true;
    }
}


//public class Task15 {
//    public static void main(String[] args) {
//        int numbers = 50;
//        System.out.println(foundOfNaturalNumber(numbers));
//    }
//
//    public static int foundOfNaturalNumber(int num) {// Я поменял имя параметра, чтобы вы не путали его с переменной из мэйн.
//        int a = 1;// Вы объявили переменную а, зря очень зря. она вам нужна только в цикле и там ее и надо было объявлять
//        int count = 0;//Вы обьявили переменную для подсчета простых чисел. тут все хорошо.
//        for (a = 1; a <= 70; a++) {//цикл от 1 до 70. я так понимаю, чтобы проверить является число простым или нет. и это не верно. на 1 делится все. и на сомо-себя делится все.
//            if (num / a == num) { //вот этими условиями вы видимо пытались проверить будет число простом или нет, но так не получится
//                if (num / a == 1) {//Это видимо продолжение условия
//                    count++;// И если оно да - то увеличиваете счетчик.
//                }
//            }
//            num++;
//            if (count == 2) {//вот так должен был выглядеть предварительный выход, по найденому числу
//                return num;
//            }
//        }
//        return 0;//А вот так резервный, потому что выход в условии может не всегда сработать, а жава требует чтобы точка выхода была всегда и была однозначной.
//    }
//    //TODO Как надо сделать
//    /*
//    *  в основной программе просто вызвать sout(foundOfNaturalNumber(50,70,2));
//    *
//    * метод int foundOfNaturalNumber(int from,int to,int numOfRet){  //Этот метод получает начало и конец диапазона, и номер простого числа которое надо вернуть
//    * делаем  переменную int count=0;
//    *  цикл для i =from; пока i<= to;i++ {
//    *    если isPrime(i) то count++;
//    *    если  count==numOfRet то return i;
//    *  }
//    * return 0; для того чтобы была точка выхода.
//    * }
//    * метод boolean isPrime(int number){ //Этот метод получает число на вход и говорит простое оно или нет
//    *  цикл для i =2; пока i<Math.sqrt(number);i++ {
//    *    если остаток от деления num на i == 0 return false;
//    *  }
//    *  return true;
//    * }
//    * // Работа метода основана на тупой попутке делить число на все что больше 1 и меньше корня квадратного из самого числа(больше бессмысленно, потому что процедура обратная делению умножение и для того чтобы получить непростое число надо умножить 2 целочисленных множителя. а раз их всегда минимум 2, то квадратный корень нам показывает максимально необходимое для проверки число).
//    * // если нашли хотя бы один делитель - сразу выходим и говорим false.
//    * */
//
//}
